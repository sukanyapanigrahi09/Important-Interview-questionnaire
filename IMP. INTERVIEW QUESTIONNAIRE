-- MOST ASKED INTERVIEW QUESTION :

--			    INTERVIEW QUESTION 1 :

--find monthly sales and sort it by DESC
CREATE TABLE Sales(
		Order_date date,
		Sales int
);

INSERT INTO Sales (Order_date, Sales)
VALUES
('2021-01-01',20), ('2021-01-02',32),('2021-02-08',45),
('2021-02-04',31),('2021-03-21',33),('2021-03-06',19),
('2021-04-07',21),('2021-04-22',10);

SELECT * FROM Sales;

SELECT EXTRACT(year from Order_date) AS years, to_char(Order_date,'Mon') AS months,
	sum(Sales) AS Total_sales
FROM Sales
--here 1, 2 means : 1 (years), 2 (months), 3 (Total_sales)
GROUP BY 1, 2
ORDER BY Total_sales DESC;	


--					INTERVIEW QUESTION 2 :

--Find the candidates best suited for an open data science job. Find caandidates who are proficient in Python, SQL,and Power Bi
--Write a query to list the candidates who possess all of the required skills for the job. Sort the output by candidate ID in ascending order.
DROP TABLE Applications ;
CREATE TABLE Applications (
		candidate_id int,
		skills varchar
);

INSERT INTO Applications (candidate_id, skills)
VALUES
(101,'Power BI'), (101,'Python'), (101,'SQL'), (102,'Tableau'), (102,'SQL'), 
(108, 'Python'), (108, 'SQL'), (108,'Power BI'), (104, 'Python'), (104, 'Excel');

SELECT * FROM Applications;

SELECT candidate_id, COUNT(skills) AS skillcount
FROM Applications
WHERE skills IN ('Python', 'Power BI', 'SQL')
GROUP BY candidate_id
HAVING COUNT(skills) = 3
ORDER BY candidate_id ASC ;


--					INTERVIEW QUESTION 3 :

--Given a table where their are obvious repeated information. we need to remove it by using 3 methods 


CREATE TABLE Travel(
source VARCHAR(20),
destination VARCHAR(20),
distance INT 
);

INSERT INTO Travel (source, destination, distance)
VALUES
('Mumbai', 'Bangalore', 500), ('Bangalore', 'Mumbai', 500), ('Delhi', 'Mathura', 150), 
('Mathura', 'Delhi', 150), ('Nagpur', 'Pune', 500), ('Pune', 'Nagpur', 500);

SELECT * FROM travel

--Method 1 : Using greatest and least function
SELECT GREATEST (source, destination), LEAST(source, destination), MAX(distance)
FROM Travel
GROUP BY GREATEST (source, destination), LEAST(source, destination);

--Method 2 : using self join

WITH cte AS 
(
SELECT *, row_number() over() AS SNo
FROM travel
)

SELECT t1.*
FROM cte AS t1
JOIN cte AS t2
ON t1.source = t2.destination
AND t1.SNo < t2.SNo

--Method 3 : using SUB Query
SELECT * FROM travel t1
WHERE NOT EXISTS ( SELECT * FROM travel t2
				   WHERE t1.source = t2.destination
				   AND t1.destination = t2.source
				   AND t1.destination > t2.destination
					
)


					INTERVIEW QUESTION 4 :

-- List all the matches between teams, if matches are played once.

CREATE TABLE match (team varchar(20));
INSERT INTO match (team)
VALUES ('India'),('Pak'),('Aus'), ('Eng');

SELECT * FROM match

--Using CTE (common table expression) and self join

with cte as (
SELECT *, ROW_NUMBER() OVER(ORDER BY team ASC) AS id
FROM MATCH
)

SELECT a.team AS "Team_A", b.team AS "Team_B" 
FROM cte as a
JOIN cte as b
ON a.team <> b.team
WHERE a.id < b.id


				INTERVIEW QUESTION 5 

--Write a query to get the desired output (given id and name)
--using 1. concatenate, 2. NTILE() 3. string aggregate function 4. Group by

CREATE TABLE emp (
ID int,
NAME VARCHAR(20)
);

INSERT INTO emp (ID, NAME)
VALUES (1,'Emp1'), (2,'Emp2'),(3,'Emp3'), (4,'Emp4'), (5,'Emp5'), (6,'Emp6'), (7,'Emp7'), (8,'Emp8')

SELECT * FROM emp;

with cte as (
SELECT *, CONCAT(ID, ' ', NAME) AS con,
NTILE(4) OVER(ORDER BY ID ASC) AS groups
FROM emp)
SELECT STRING_AGG(con, ', ') AS result, groups
FROM cte
group by groups
order by groups


					INTERVIEW QUESTION 6 :


CREATE TABLE Employee (
EmpID int NOT NULL,
EmpName Varchar,
Gender Char,
Salary int,
City Char(20) )


INSERT INTO Employee
VALUES (1, 'Arjun', 'M', 75000, 'Pune'),
(2, 'Ekadanta', 'M', 125000, 'Bangalore'),
(3, 'Lalita', 'F', 150000 , 'Mathura'),
(4, 'Madhav', 'M', 250000 , 'Delhi'),
(5, 'Visakha', 'F', 120000 , 'Mathura')


CREATE TABLE EmployeeDetail (
EmpID int NOT NULL,
Project Varchar,
EmpPosition Char(20),
DOJ date )


INSERT INTO EmployeeDetail
VALUES (1, 'P1', 'Executive', '26-01-2019'),
(2, 'P2', 'Executive', '04-05-2020'),
(3, 'P1', 'Lead', '21-10-2021'),
(4, 'P3', 'Manager', '29-11-2019'),
(5, 'P2', 'Manager', '01-08-2020')

--Q1(a): Find the list of employees whose salary ranges between 2L to 3L.

SELECT empname, salary FROM Employee
WHERE salary BETWEEN 200000 AND 300000 
--			OR
SELECT EmpName, Salary FROM Employee
WHERE Salary > 200000 AND Salary < 300000

--Q1(b): Write a query to retrieve the list of employees from the same city.

SELECT E1.EmpID, E1.EmpName, E1.City
FROM Employee E1, Employee E2
WHERE E1.City = E2.City AND E1.EmpID != E2.EmpID

--Q1(c): Query to find the null values in the Employee table.

SELECT * FROM Employee
WHERE EmpID IS NULL

--Q2(a): Query to find the cumulative sum of employee’s salary. (Inorder to find out the cumulative sum we shall use the OVER clause after SUM())

SELECT empid, empname, salary, SUM(salary) OVER (ORDER BY empid) AS cum_salary
FROM Employee

--Q2(b): What’s the male and female employees ratio.

SELECT 
(COUNT(*)FILTER (WHERE Gender = 'M') * 100.0 / count(*)) As Male_ratio,
(COUNT(*)FILTER (WHERE Gender = 'F') * 100.0 / count(*)) As Male_ratio 
FROM Employee; 

--Q2(c): Write a query to fetch 50% records from the Employee table.


SELECT * FROM Employee
WHERE EmpID <= (SELECT COUNT(*)/2 FROM Employee)


--Subquery is a part of main query


--Q3: Query to fetch the employee’s salary but replace the LAST 2 digits with ‘XX’ i.e 12345 will be 123XX

SELECT Salary,
CONCAT(SUBSTRING(Salary::text, 1, LENGTH(Salary::text)-2), 'XX') as masked_number
FROM Employee

/* NOTE : (Step-by-step breakdown:
Salary::text

Converts the Salary (usually numeric or integer) into a text string so you can manipulate it.

Example: 54321::text → '54321'

LENGTH(Salary::text)

Calculates how many characters are in the salary string.

'54321' → 5

LENGTH(Salary::text) - 2

Subtracts 2 from the total length so you can chop off the last two digits.

5 - 2 = 3

SUBSTRING(Salary::text, 1, LENGTH(Salary::text) - 2)

Extracts the first N-2 characters from the string.

SUBSTRING('54321', 1, 3) → '543'

CONCAT(..., 'XX')

Appends 'XX' to the front portion.

'543' || 'XX' → '543XX')*/

--- OR –--

SELECT Salary, CONCAT(LEFT(CAST(Salary AS text), LENGTH(CAST(Salary AS text))-2), 'XX')
AS masked_number
FROM Employee

/* CAST(Salary AS text)

Same as Salary::text: converts the number to text.

Example: 54321 → '54321'

LENGTH(CAST(Salary AS text))

Counts the number of characters in the string.

LENGTH(...) - 2

Subtract 2 to determine how many characters to keep.

LEFT(..., LENGTH(...) - 2)

LEFT(string, n) gets the first n characters.

Example: LEFT('54321', 3) → '543'

CONCAT(..., 'XX')

Add 'XX' to the end, getting '543XX'. */



-- Q4: Write a query to fetch even and odd rows from Employee table.

-- Using Row_number()
---Fetch even rows
SELECT * FROM

(SELECT *, ROW_NUMBER() OVER(ORDER BY EmpId) AS
RowNumber
FROM Employee) AS Emp
WHERE Emp.RowNumber % 2 = 0
---Fetch odd rows
SELECT * FROM

(SELECT *, ROW_NUMBER() OVER(ORDER BY EmpId) AS
RowNumber
FROM Employee) AS Emp
WHERE Emp.RowNumber % 2 = 1

-- ALTERNATIVE SOLUTION : If you have an auto-increment field like EmpID then we can use the MOD() function: we can only use mod() fuction when there are numeric values only

---Fetch even rows

SELECT * FROM Employee
WHERE MOD(EmpID,2)=0;
---Fetch odd rows

SELECT * FROM Employee
WHERE MOD(EmpID,2)=1;

/*Q5(a): Write a query to find all the Employee names whose name:
• Begin with ‘A’
• Contains ‘A’ alphabet at second place
• Contains ‘Y’ alphabet at second last place
• Ends with ‘L’ and contains 4 alphabets
• Begins with ‘V’ and ends with ‘A’ */

SELECT * FROM Employee WHERE EmpName LIKE 'A%';
SELECT * FROM Employee WHERE EmpName LIKE '_a%';
SELECT * FROM Employee WHERE EmpName LIKE '%y_';
SELECT * FROM Employee WHERE EmpName LIKE '____l';
SELECT * FROM Employee WHERE EmpName LIKE 'V%a'

/*Q5(b): Write a query to find the list of Employee names which is:
• starting with vowels (a, e, i, o, or u), without duplicates
• ending with vowels (a, e, i, o, or u), without duplicates
• starting & ending with vowels (a, e, i, o, or u), without duplicates */

SELECT DISTINCT EmpName
FROM Employee
WHERE LOWER(EmpName) SIMILAR TO '[aeiou]%'

SELECT DISTINCT EmpName
FROM Employee
WHERE LOWER(EmpName) SIMILAR TO '%[aeiou]'

SELECT DISTINCT EmpName
FROM Employee
WHERE LOWER(EmpName) SIMILAR TO '[aeiou]%[aeiou]'



--Corelated nexted query (doubt ??)


--Q6: Find Nth highest salary from employee table with and without using the TOP/LIMIT keywords.

--Without using TOP/LIMIT 

SELECT Salary FROM Employee E1
WHERE N-1 = (
SELECT COUNT( DISTINCT ( E2.Salary ) )
FROM Employee E2
WHERE E2.Salary > E1.Salary );

--- OR ---
SELECT Salary FROM Employee E1
WHERE N = (
SELECT COUNT( DISTINCT ( E2.Salary ) )
FROM Employee E2
WHERE E2.Salary >= E1.Salary );

--Using LIMIT 
SELECT Salary FROM Employee
ORDER BY Salary DESC
LIMIT 1 OFFSET N-1

--Using TOP
SELECT TOP 1 Salary
FROM Employee
WHERE Salary < (
SELECT MAX(Salary) FROM Employee)
AND Salary NOT IN (
SELECT TOP 2 Salary
FROM Employee
ORDER BY Salary DESC)
ORDER BY Salary DESC;

--Q7(a): Write a query to find and remove duplicate records from a table.
SELECT EmpID, EmpName, gender, Salary, city,
COUNT(*) AS duplicate_count
FROM Employee
GROUP BY EmpID, EmpName, gender, Salary, city
HAVING COUNT(*) > 1;

DELETE FROM Employee
WHERE EmpID IN
(SELECT EmpID FROM Employee
GROUP BY EmpID
HAVING COUNT(*) > 1);

--Q7(b): Query to retrieve the list of employees working in same project.

WITH CTE AS

(SELECT e.EmpID, e.EmpName, ed.Project
FROM Employee AS e
INNER JOIN EmployeeDetail AS ed
ON e.EmpID = ed.EmpID)

SELECT c1.EmpName, c2.EmpName, c1.project
FROM CTE c1, CTE c2
WHERE c1.Project = c2.Project AND c1.EmpID != c2.EmpID AND c1.EmpID < c2.EmpID

--Q8: Show the employee with the highest salary for each project

SELECT ed.Project, MAX(e.Salary) AS ProjectSal
FROM Employee AS e
INNER JOIN EmployeeDetail AS ed
ON e.EmpID = ed.EmpID
GROUP BY Project
ORDER BY ProjectSal DESC;
--Similarly we can find Total Salary for each project, just use SUM() instead of MAX()
--Alternative, more dynamic solution: here you can fetch EmpName, 2nd/3rd highest value, etc

WITH CTE AS
(SELECT project, EmpName, salary,
ROW_NUMBER() OVER (PARTITION BY project ORDER BY salary DESC) AS row_rank
FROM Employee AS e
INNER JOIN EmployeeDetail AS ed
ON e.EmpID = ed.EmpID)
SELECT project, EmpName, salary
FROM CTE
WHERE row_rank = 1;

--Q9: Query to find the total count of employees joined each year
SELECT EXTRACT('year' FROM doj) AS JoinYear, COUNT(*) AS EmpCount
FROM Employee AS e
INNER JOIN EmployeeDetail AS ed ON e.EmpID = ed.EmpID
GROUP BY JoinYear
ORDER BY JoinYear ASC

--Q10: Create 3 groups based on salary col, salary less than 1L is low, between 1 - 2L is medium and above 2L is High
SELECT EmpName, Salary,

CASE
WHEN Salary > 200000 THEN 'High'
WHEN Salary >= 100000 AND Salary <= 200000 THEN 'Medium'
ELSE 'Low'
END AS SalaryStatus

FROM Employee

--BONUS: Query to pivot the data in the Employee table and retrieve the total salary for each city. The result should display the EmpID, EmpName, and separate columns for each city (Mathura, Pune, Delhi), containing the corresponding total salary.
SELECT
EmpID,
EmpName,
SUM(CASE WHEN City = 'Mathura' THEN Salary END) AS "Mathura",
SUM(CASE WHEN City = 'Pune' THEN Salary END) AS "Pune",
SUM(CASE WHEN City = 'Delhi' THEN Salary END) AS "Delhi"
FROM Employee
GROUP BY EmpID, EmpName;



HACKER RANK :

Query the list of CITY names STARTing with vowels (a, e, i, o, u) from STATION. Your result cannot contain duplicates.

--using LIKE, ILIKE, REGEXP(Only MYSQL) 

SELECT DISTINCT FROM STATION 
WHERE CITY LIKE 'a%' OR
CITY LIKE 'e%' OR
CITY LIKE 'i%' OR
CITY LIKE 'o%' OR
CITY LIKE 'u%'
 
Query the list of CITY names ending with vowels (a, e, i, o, u) from STATION. Your result cannot contain duplicates.

--using BITWISE operator (RIGHT) and MEMBERSHIP operator (IN)

Query the list of CITY names from STATION which have vowels (i.e., a, e, i, o, and u) as both their first and last characters. Your result cannot contain duplicates.

SELECT DISTINCT CITY FROM STATION 

WHERE 

(CITY LIKE 'a%' OR
CITY LIKE 'e%' OR
CITY LIKE 'i%' OR
CITY LIKE 'o%' OR
CITY LIKE 'u%')

AND

(CITY LIKE '%a' OR
CITY LIKE '%e' OR
CITY LIKE '%i' OR
CITY LIKE '%o' OR
CITY LIKE '%u')


OR 

SELECT DISTINCT CITY FROM STATION 
WHERE 
LEFT(CITY,1) IN ('a','e','i','o','u')

AND

RIGHT(CITY,1) IN ('a','e','i','o','u')

--Query the list of CITY names from STATION that do not end with vowels. Your result cannot contain duplicates.

SELECT DISTINCT CITY FROM STATION
WHERE
    RIGHT(CITY, 1) NOT IN ('a','e','i','o','u')

--Query the list of CITY names from STATION that do not start with vowels and do not end with vowels. Your result cannot contain duplicates.

SELECT DISTINCT CITY FROM STATION 

WHERE 
LEFT(CITY,1) NOT IN ('a','e','i','o','u')

AND

RIGHT(CITY,1) NOT IN ('a','e','i','o','u')


--Query the Name of any student in STUDENTS who scored higher than 75 Marks. Order your output by the last three characters of each name. If two or more students both have names ending in the same last three characters (i.e.: Bobby, Robby, etc.), secondary sort them by ascending ID.

SELECT NAME FROM STUDENTS
WHERE MARKS > 75
ORDER BY RIGHT(NAME, 3), ID ASC


--Write a query that prints a list of employee names (i.e.: the name attribute) for employees in Employee having a salary greater than $2000 per month who have been employees for less than 10 months. Sort your result by ascending employee_id.


Q. Julia asked her students to create some coding challenges. Write a query to print the hacker_id, name, and the total number of challenges created by each student. Sort your results by the total number of challenges in descending order. If more than one student created the same number of challenges, then sort the result by hacker_id. If more than one student created the same number of challenges and the count is less than the maximum number of challenges created, then exclude those students from the result. (DOUBT)

SELECT h.hacker_id, h.name, COUNT(c.challenge_id) AS total_challenges
FROM Hackers h
JOIN Challenges c ON h.hacker_id = c.hacker_id
GROUP BY h.hacker_id, h.name
HAVING COUNT(c.challenge_id) = (
    SELECT MAX(challenge_count)
    FROM (
        SELECT COUNT(*) AS challenge_count
        FROM Challenges
        GROUP BY hacker_id
    ) AS sub
)
OR COUNT(c.challenge_id) IN (
    SELECT challenge_count
    FROM (
        SELECT COUNT(*) AS challenge_count
        FROM Challenges
        GROUP BY hacker_id
    ) AS sub
    GROUP BY challenge_count
    HAVING COUNT(*) = 1
)
ORDER BY total_challenges DESC, h.hacker_id ASC;



Q. Pivot the Occupation column in OCCUPATIONS so that each Name is sorted alphabetically and displayed underneath its corresponding Occupation. The output should consist of four columns (Doctor, Professor, Singer, and Actor) in that specific order, with their respective names listed alphabetically under each column. (doubt)


SQL certificate exam (basics) from hacker rank :

Q. On the basis of merit, a company decides to promote some of its employees in its HR division at the end of the quarter because of their high performance. Write a query to find the employee IDs along with the names of all its employees who work in the HR department who earned a bonus of 5000 dollars or more in the last quarter.

SELECT ei.employee_ID, ei.name
FROM employee_information ei JOIN last_quarter_bonus lqbonus 
ON ei.employee_ID = lqbonus.employee_ID
WHERE ei.division = 'HR'
AND lqbonus.bonus >= 5000;

Q. A stock is considered profitable if the predicted price is strictly greater than the current price. Write a query to find the stock_codes of all the stocks which are profitable based on this definition. Sort the output in ascending order.

SELECT price_today.stock_code
FROM price_today JOIN price_tomorrow
ON price_today.stock_code = price_tomorrow.stock_code
WHERE price_tomorrow.price > price_today.price;


TechTFQ : 

Write a SQL Query to fetch all the duplicate records in a table.
Table Name: USERS

Note: Record is considered duplicate if a user name is present more than once.

Approach: Partition the data based on user name and then give a row number to each of the partitioned user name. If a user name exists more than once then it would have multiple row numbers. Using the row number which is other than 1, we can identify the duplicate records.

-- Query 1:

Write a SQL query to fetch all the duplicate records from a table.

--Tables Structure:

drop table users;
create table users
(
user_id int primary key,
user_name varchar(30) not null,
email varchar(50));

insert into users values
(1, 'Sumit', 'sumit@gmail.com'),
(2, 'Reshma', 'reshma@gmail.com'),
(3, 'Farhana', 'farhana@gmail.com'),
(4, 'Robin', 'robin@gmail.com'),
(5, 'Robin', 'robin@gmail.com');

select * from users;

-- Solution 1:

-- Replace ctid with rowid for Oracle, MySQL and Microsoft SQLServer
select *
from users u
where u.ctid not in (
select min(ctid) as ctid
from users
group by user_name
order by ctid);


-- Solution 2: Using window function.

select user_id, user_name, email
from (
select *,
row_number() over (partition by user_name order by user_id) as rn
from users u
order by user_id) x
where x.rn <> 1;

